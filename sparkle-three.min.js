(function (global) {
    function require(file, parentModule) {
        if ({}.hasOwnProperty.call(require.cache, file))
            return require.cache[file];
        var resolved = require.resolve(file);
        if (!resolved)
            throw new Error('Failed to resolve module ' + file);
        var module$ = {
                id: file,
                require: require,
                filename: file,
                exports: {},
                loaded: false,
                parent: parentModule,
                children: []
            };
        if (parentModule)
            parentModule.children.push(module$);
        var dirname = file.slice(0, file.lastIndexOf('/') + 1);
        require.cache[file] = module$.exports;
        resolved.call(module$.exports, module$, module$.exports, dirname, file);
        module$.loaded = true;
        return require.cache[file] = module$.exports;
    }
    require.modules = {};
    require.cache = {};
    require.resolve = function (file) {
        return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
    };
    require.define = function (file, fn) {
        require.modules[file] = fn;
    };
    var process = function () {
            var cwd = '/';
            return {
                title: 'browser',
                version: 'v0.10.5',
                browser: true,
                env: {},
                argv: [],
                nextTick: global.setImmediate || function (fn) {
                    setTimeout(fn, 0);
                },
                cwd: function () {
                    return cwd;
                },
                chdir: function (dir) {
                    cwd = dir;
                }
            };
        }();
    require.define('/index.js', function (module, exports, __dirname, __filename) {
        exports.Emitter = require('/emitter.js', module).Emitter;
        exports.colorInitializer = require('/initializers/color.js', module).color;
        exports.geometryZone = require('/zones/geometry.js', module).geometry;
        exports.circleTexture = require('/textures.js', module).circle;
    });
    require.define('/textures.js', function (module, exports, __dirname, __filename) {
        var createCanvas = function (resolution, options) {
            var canvas = document.createElement('canvas');
            canvas.width = canvas.height = resolution;
            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            var context = canvas.getContext('2d');
            return {
                canvas: canvas,
                texture: texture,
                context: context
            };
        };
        exports.circle = function (resolution, options) {
            if (typeof options === 'undefined')
                options = {};
            var element = createCanvas(resolution, options);
            element.context.beginPath();
            element.context.arc(resolution / 2, resolution / 2, resolution / 2, 0, Math.PI * 2, false);
            element.context.closePath();
            if (options.stops != null) {
                element.context.fillStyle = element.context.createRadialGradient(resolution / 2, resolution / 2, 0, resolution / 2, resolution / 2, resolution / 2);
                Object.keys(options.stops).sort().forEach(function (stop) {
                    element.context.fillStyle.addColorStop(stop, 'rgba( %n, %n, %n, 1)'.replace(/%n/g, 255 * options.stops[stop]));
                });
            } else {
                element.context.fillStyle = 'white';
            }
            element.context.fill();
            return element.texture;
        };
    });
    require.define('/zones/geometry.js', function (module, exports, __dirname, __filename) {
        var triangleArea = function (a, b, c) {
            return 0.5 * Math.sqrt(Math.pow(b.x * c.y - c.x * b.y, 2) + Math.pow(c.x * a.y - a.x * c.y, 2) + Math.pow(a.x * b.y - b.x * a.y, 2));
        };
        exports.geometry = function (geometry) {
            var total = 0;
            var faces = [];
            geometry.faces.forEach(function (face) {
                var triangle = {
                        a: geometry.vertices[face.a],
                        b: geometry.vertices[face.b],
                        c: geometry.vertices[face.c]
                    };
                var area = triangleArea(triangle.a, triangle.b, triangle.c);
                faces.push({
                    position: total,
                    face: triangle
                });
                total += area;
            });
            return function (vector) {
                var r = Math.random() * total, closest = null, diff = Number.POSITIVE_INFINITY;
                for (var t = 0, T = faces.length; t < T; ++t) {
                    var currentDiff = Math.abs(r - faces[t].position);
                    if (currentDiff < diff) {
                        closest = t;
                        diff = currentDiff;
                    }
                }
                var face = faces[closest];
                var b0 = Math.random();
                var b1 = (1 - b0) * Math.random();
                var b2 = 1 - b0 - b1;
                vector[0] = face.face.a.x * b0 + face.face.b.x * b1 + face.face.c.x * b2;
                vector[1] = face.face.a.y * b0 + face.face.b.y * b1 + face.face.c.y * b2;
                vector[2] = face.face.a.z * b0 + face.face.b.z * b1 + face.face.c.z * b2;
            };
        };
    });
    require.define('/initializers/color.js', function (module, exports, __dirname, __filename) {
        exports.color = function (zone, mode) {
            if (typeof mode === 'undefined') {
                mode = 'RGB';
            } else {
                mode = mode.toUpperCase();
            }
            var vector = [
                    NaN,
                    NaN,
                    NaN
                ];
            return function (particle) {
                if (!particle.color)
                    particle.color = new THREE.Color();
                SPARKLE.utils.asVector(zone, vector);
                particle.color['set' + mode](vector[0], vector[1], vector[2]);
            };
        };
    });
    require.define('/emitter.js', function (module, exports, __dirname, __filename) {
        var DefaultMaterial = require('/material.js', module).Material;
        var Emitter = exports.Emitter = function (options) {
                this.options = options = options || {};
                var count = this.options.count != null ? this.options.count : 100;
                var material = this.options.material ? this.options.material : new DefaultMaterial(count, {
                        texture: this.options.texture,
                        size: this.options.size,
                        blending: this.options.blending
                    });
                var geometry = new THREE.Geometry();
                this.particleIndexPool = [];
                for (var t = 0, T = count; t < T; ++t) {
                    var inf = Number.POSITIVE_INFINITY;
                    var particle = new THREE.Vector3(inf, inf, inf);
                    geometry.vertices.push(particle);
                    this.particleIndexPool.push(t);
                }
                THREE.ParticleSystem.call(this, geometry, material);
                this.dynamic = true;
                var frequency = this.options.frequency != null ? this.options.frequency : 0.1;
                this.emitter = new SPARKLE.Emitter(frequency);
                this.emitter.initializer(function (particle) {
                    particle.vertice = this.particleIndexPool.pop();
                }.bind(this));
                if (this.options.position != null) {
                    this.emitter.initializer(SPARKLE.positionInitializer(this.options.position));
                } else {
                    this.emitter.initializer(SPARKLE.positionInitializer([
                        0,
                        0,
                        0
                    ]));
                }
                if (this.options.lifeTime != null) {
                    this.emitter.initializer(SPARKLE.lifeTimeInitializer(this.options.lifeTime));
                    this.emitter.action(SPARKLE.ageAction(this.options.eternal));
                    if (options.fading) {
                        this.emitter.action(SPARKLE.fadeAction(typeof this.options.fading === 'function' ? this.options.fading : undefined));
                    }
                    if (options.pulsing) {
                        this.emitter.action(SPARKLE.pulseAction(typeof this.options.pulsing === 'function' ? this.options.pulsing : undefined));
                    }
                }
                if (this.options.velocity != null) {
                    this.emitter.initializer(SPARKLE.velocityInitializer(this.options.velocity));
                    if (options.acceleration != null)
                        this.emitter.action(SPARKLE.accelerateAction(this.options.acceleration[0], this.options.acceleration[1], this.options.acceleration[2]));
                    this.emitter.action(SPARKLE.moveAction());
                }
                if (this.options.color != null) {
                    this.emitter.initializer(SPARKLE.THREE.colorInitializer(this.options.color, this.options.colorMode));
                }
                if (this.options.initializers != null) {
                    this.options.initializers.forEach(function (initializer) {
                        this.emitter.initializer(initializer);
                    }, this);
                }
                if (this.options.actions != null) {
                    this.options.actions.forEach(function (action) {
                        this.emitter.action(action);
                    }, this);
                }
                this.emitter.onWakeUp = this.onWakeUp.bind(this);
                this.emitter.onUpdate = this.onUpdate.bind(this);
                this.emitter.onSleep = this.onSleep.bind(this);
                if (this.options.initial != null) {
                    this.emitter.spawn(this.options.initial[0], this.options.initial[1]);
                }
            };
        var F = function () {
        };
        F.prototype = THREE.ParticleSystem.prototype;
        Emitter.prototype = new F();
        Emitter.prototype.constructor = Emitter;
        Emitter.prototype.update = function (delta, updates) {
            this.emitter.update(delta);
            if (updates != null)
                for (var t = 0, T = updates.length; t < T; ++t)
                    this.material.attributes[updates[t]].needsUpdate = true;
            if (this.options.pulsing)
                this.material.attributes.aSize.needsUpdate = true;
            if (this.options.fading)
                this.material.attributes.aOpacity.needsUpdate = true;
            if (this.options.velocity)
                this.geometry.verticesNeedUpdate = true;
            return this;
        };
        Emitter.prototype.spawn = function (count, randomly) {
            this.emitter.spawn(count, randomly);
            return this;
        };
        Emitter.prototype.onWakeUp = function (particle, delta) {
            if (particle.vertice == null)
                return;
            if (this.options.color) {
                this.material.attributes.aColor.value[particle.vertice] = particle.color;
                this.material.attributes.aColor.needsUpdate = true;
            }
        };
        Emitter.prototype.onUpdate = function (particle, delta) {
            if (particle.vertice == null)
                return;
            if (this.options.pulsing)
                this.material.attributes.aSize.value[particle.vertice] = particle.size;
            if (this.options.fading)
                this.material.attributes.aOpacity.value[particle.vertice] = particle.opacity;
            if (this.options.velocity) {
                this.geometry.vertices[particle.vertice].fromArray(particle.position);
            }
        };
        Emitter.prototype.onSleep = function (particle, delta) {
            if (particle.vertice == null)
                return;
            var inf = Number.POSITIVE_INFINITY;
            this.geometry.vertices[particle.vertice].set(inf, inf, inf);
            this.geometry.verticesNeedUpdate = true;
            this.particleIndexPool.push(particle.vertice);
        };
    });
    require.define('/material.js', function (module, exports, __dirname, __filename) {
        var vertexShaderGlsl = require('/shaders/vertex.glsl', module);
        var fragmentShaderGlsl = require('/shaders/fragment.glsl', module);
        var defaultTexture = require('/textures.js', module).circle(128, {
                stops: {
                    0: 1,
                    1: 0
                }
            });
        var Material = exports.Material = function (count, options) {
                this.options = options;
                var uniforms = {
                        texture: {
                            type: 't',
                            value: this.options.texture || defaultTexture
                        },
                        size: {
                            type: 'f',
                            value: this.options.size || 40
                        }
                    };
                var attributes = {
                        aColor: {
                            type: 'c',
                            value: []
                        },
                        aSize: {
                            type: 'f',
                            value: []
                        },
                        aOpacity: {
                            type: 'f',
                            value: []
                        }
                    };
                var randomColor = function (r, g, b) {
                    var color = new THREE.Color(16777215);
                    color.r = r * Math.random();
                    color.g = g * Math.random();
                    color.b = b * Math.random();
                    return color;
                };
                for (var t = 0, T = count; t < T; ++t) {
                    attributes.aOpacity.value[t] = 1;
                    attributes.aColor.value[t] = randomColor(0.3, 0.3, 0.3);
                    attributes.aSize.value[t] = 1;
                }
                THREE.ShaderMaterial.call(this, {
                    uniforms: uniforms,
                    attributes: attributes,
                    vertexShader: vertexShaderGlsl,
                    fragmentShader: fragmentShaderGlsl,
                    blending: this.options.blending != null ? this.options.blending : THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });
            };
        var F = function () {
        };
        F.prototype = THREE.ShaderMaterial.prototype;
        Material.prototype = new F();
        Material.prototype.Shader = Material;
    });
    require.define('/shaders/fragment.glsl', function (module, exports, __dirname, __filename) {
        module.exports = 'uniform sampler2D texture;\n\nvarying vec3  vColor;\nvarying float vDepth;\nvarying float vOpacity;\n\nvoid main( void ) {\n\n    vec4 outColor = texture2D( texture, gl_PointCoord );\n\n    gl_FragColor = outColor * vec4( vColor, 1.0 );\n    gl_FragColor.xyz *= (300.0 - vDepth ) / 300.0;\n    gl_FragColor.a *= vOpacity;\n\n}\n';
    });
    require.define('/shaders/vertex.glsl', function (module, exports, __dirname, __filename) {
        module.exports = 'uniform float size;\n\nattribute vec3  aColor;\nattribute float aSize;\nattribute float aOpacity;\n\nvarying vec3  vColor;\nvarying float vDepth;\nvarying float vOpacity;\n\nvoid main( void ) {\n\n    vColor = aColor;\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec4 csPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    vDepth = csPosition.z;\n\n    vOpacity = aOpacity;\n\n    gl_PointSize = size * aSize * ( 100.0 / length( mvPosition.xyz ) );\n    gl_Position = projectionMatrix * mvPosition;\n\n}\n';
    });
    SPARKLE.THREE = require('/index.js');
}.call(this, this));